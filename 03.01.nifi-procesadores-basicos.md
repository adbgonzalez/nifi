# 03.01 Procesadores básicos en Apache NiFi

Este documento recolle fichas completas dos 10 procesadores básicos usados habitualmente nos fluxos de Apache NiFi. A idea é servir como chuleta de referencia rápida para o módulo.

---

## 1.1. GenerateFlowFile

### 1. Descrición
`GenerateFlowFile` crea novos FlowFiles de maneira autónoma, sen ler de ningunha fonte externa. É ideal para probas, simulacións, exercicios e xeración de datos sintéticos.

### 2. Función principal
- Xerar FlowFiles a intervalos regulares.
- Crear contido fixo (texto) ou aleatorio (bytes).
- Engadir atributos personalizados.
- Simular cargas ou eventos de entrada.

### 3. Propiedades principais

| Propiedade      | Tipo    | Descrición                                                                 |
|-----------------|---------|----------------------------------------------------------------------------|
| Custom Text     | Texto   | Contido exacto do FlowFile. Se se indica, ignora `File Size`.             |
| File Size       | Tamaño  | Tamaño do contido aleatorio (ex. `1 KB`, `10 MB`) se non hai `Custom Text`. |
| Batch Size      | Número  | Número de FlowFiles creados por execución.                                |
| Data Format     | Enum    | `Text` ou `Binary`.                                                       |
| Unique FlowFiles| Boolean | Se é `true`, xera FlowFiles cun contido/UUID únicos para cada execución.  |
| Attributes      | Texto   | Lista de pares `clave=valor` para crear atributos adicionais.             |

### 4. Relacións

| Relationship | Significado                    |
|-------------|---------------------------------|
| success     | Todos os FlowFiles xerados      |

### 5. Exemplo de uso típico
Exemplo “Ola mundo”:
- `Custom Text = Ola mundo desde NiFi`
- `Run Schedule = 5 sec`
- `Batch Size = 1`
- Conectado a `LogAttribute` para ver o contido.

### 6. Situacións típicas onde se usa
- Probar fluxos sen depender de fontes externas.
- Simular chegada de ficheiros/eventos.
- Xerar cargas de proba para Kafka, MinIO ou HDFS.

### 7. Erros comúns

| Erro             | Causa                                               |
|------------------|-----------------------------------------------------|
| Contido baleiro  | Non se definiu `Custom Text` nin `File Size`.       |
| Demasiados datos | `Batch Size` alto + `Run Schedule` moi curto.       |

### 8. Boas prácticas
- Usar `Custom Text` en exercicios para ter contido reproducible.
- Manter `Batch Size` baixo en contornos de proba.
- Evitar `Run Schedule = 0 sec` en portátiles/entornos lixeiros.

---

## 1.2. LogAttribute

### 1. Descrición
`LogAttribute` escribe no log de NiFi os atributos dun FlowFile e, opcionalmente, o contido. É un procesador puramente de depuración.

### 2. Función principal
- Ver atributos dun FlowFile (filename, path, uuid, etc.).
- Comprobar cambios feitos por outros procesadores.
- Depurar rutas e condicións dun fluxo.

### 3. Propiedades principais

| Propiedade      | Tipo    | Descrición                                                                  |
|-----------------|---------|-----------------------------------------------------------------------------|
| Log Payload     | Boolean | Se é `true`, escribe tamén o contido no log.                               |
| Attributes to Log | Texto | Lista de atributos a mostrar (se se deixa baleiro, mostra todos).          |
| Log Level       | Enum    | Nivel de log (INFO, DEBUG, etc.).                                          |

### 4. Relacións

| Relationship | Significado                        |
|-------------|-------------------------------------|
| success     | O FlowFile continúa sen modificación|

### 5. Exemplo de uso típico
Conectar ao final dunha nova rama:
- `RouteOnAttribute → LogAttribute`
para ver que FlowFiles pasan pola ruta e con que atributos.

### 6. Situacións típicas onde se usa
- Depuración de fluxos en desenvolvemento.
- Verificar valores de atributos antes de PutS3Object, PutHDFS…
- Comprobar se un `UpdateAttribute` fixo o esperado.

### 7. Erros comúns

| Erro                        | Causa                                 |
|-----------------------------|---------------------------------------|
| Non se ve o contido         | `Log Payload` está en `false`.        |
| Log saturado de información | Usar en loops ou con moitos datos.    |

### 8. Boas prácticas
- Poñelo sempre durante o deseño nunha nova rama.
- Eliminalo ou deshabilitalo en produción.
- Usar só en puntos clave (non en TODOS os procesadores).

---

## 1.3. UpdateAttribute

### 1. Descrición
`UpdateAttribute` crea, modifica ou elimina atributos dun FlowFile usando NiFi Expression Language.

### 2. Función principal
- Engadir metadatos (bucket, ruta, tags…).
- Construír nomes de ficheiro dinámicos.
- Adaptar atributos para outros procesadores.

### 3. Propiedades principais

Cada propiedade é un atributo novo/modificado:

| Exemplo de propiedade | Tipo        | Descrición                                       |
|-----------------------|------------|-------------------------------------------------|
| filename              | EL / Texto | Nome do ficheiro (ex. `data-${now():...}.json`) |
| bucket                | EL / Texto | Bucket de destino (ex. `nifi-test`).            |

### 4. Relacións

| Relationship | Significado                     |
|-------------|----------------------------------|
| success     | FlowFile actualizado correctamente |

### 5. Exemplo de uso típico
```text
bucket = nifi-test
filename = nifi-${now():format('yyyyMMdd-HHmmss')}.txt
```
Antes dun PutS3Object para subir o FlowFile a MinIO.

### 6. Situacións típicas onde se usa

Parametrizar rutas/buckets.

Engadir timestamps e identificadores.

Preparar atributos para roteo posterior.

### 7. Erros comúns
| Erro | Causa                     |
|-------------|----------------------------------|
| Valor inesperado     | Expresión EL mal escrita. |
| Atributo non existe | ribiuse mal o nome da clave.|

### 8. Boas prácticas

- Usar nomes de atributos consistentes (bucket, path, target.dir…).
- Non abusar para manipular contido; é para metadatos.
- Combinado con Parameter Contexts para máis flexibilidade.

## 1.4. ReplaceText

### 1. Descrición
`ReplaceText` modifica o contido dun FlowFile usando texto fixo ou expresións regulares. Traballa directamente sobre os bytes do contido, non sobre atributos.

### 2. Función principal
- Substituír patróns ou cadeas dentro do contido.
- Construír mensaxes sinxelas (JSON, XML, texto plano).
- Limpeza básica de cadeas ou normalización.

### 3. Propiedades principais
| Propiedade           | Tipo    | Descrición                                                    |
|----------------------|---------|----------------------------------------------------------------|
| Search Value         | Regex   | Texto ou patrón a buscar.                                     |
| Replacement Value    | Texto/EL| Texto substitutivo, admite Expression Language.               |
| Replacement Strategy | Enum    | Estratexia: `Literal Replace`, `Regex Replace`, `Entire Text`. |
| Evaluation Mode      | Enum    | Modo de avaliación (por liña, por contido completo…).         |

### 4. Relacións
| Relationship | Significado                      |
|-------------|-----------------------------------|
| success     | Contido modificado               |
| failure     | Ocorreu un erro na substitución  |

### 5. Exemplo de uso típico
Construír un JSON simple para enviar vía HTTP:

```
Replacement Strategy = Entire Text
Replacement Value = {"mensaxe":"Ola mundo desde NiFi"}
```

### 6. Situacións típicas onde se usa
- Pequenas correccións de formato.
- Engadir cabeceiras/pés en ficheiros de texto.
- Preparar payloads para InvokeHTTP.

### 7. Erros comúns
| Erro             | Causa                           |
|------------------|---------------------------------|
| Non hai cambios  | `Search Value` non coincide.    |
| JSON inválido    | Concatenación manual incorrecta.|

### 8. Boas prácticas
- Non usar ReplaceText para transformar JSON complexos → mellor Record API.
- Empregar sempre `Entire Text` cando queremos substituír todo o contido.
- Validar a expresión regular antes nunha ferramenta externa.

---

## 1.5. ExtractText

### 1. Descrición
`ExtractText` extrae información do contido mediante expresións regulares e gárdaa como atributos.

### 2. Función principal
- Converter texto en atributos estruturados.
- Extraer campos concretos de logs e ficheiros planos.
- Crear metadatos útiles para roteo ou clasificación.

### 3. Propiedades principais
Cada propiedade define un atributo novo:
| Propiedade (atributo) | Tipo  | Descrición                                      |
|------------------------|-------|-------------------------------------------------|
| http_code              | Regex | Ex: `.*\s(\d{3})\s.*` para extraer códigos.   |
| user_id                | Regex | Ex: `user=(\w+)`                               |

### 4. Relacións
| Relationship | Significado                                          |
|-------------|-------------------------------------------------------|
| success     | Extracción correcta (aínda que o resultado sexa baleiro) |

### 5. Exemplo
Extraer un código HTTP dun log e gardalo como atributo.

### 6. Situacións típicas
- Análise de logs.
- Extraer valores clave de ficheiros non estruturados.
- Preparar atributos que se usan en `RouteOnAttribute`.

### 7. Erros comúns
| Erro            | Causa                         |
|-----------------|-------------------------------|
| Atributo baleiro| A regex non coincide.         |
| Captura incorrecta | A regex non usa grupos ()  |

### 8. Boas prácticas
- Probar regex nun editor externo antes.
- Non empregar para JSON (usar EvaluateJsonPath).
- Poñer nomes de atributos claros e consistentes.

---

## 1.6. EvaluateJsonPath

### 1. Descrición
`EvaluateJsonPath` extrae campos dun JSON usando JSONPath e gárdaos como atributos.

### 2. Función principal
- Extracción de campos específicos.
- Validación mínima e inspección de JSON.
- Crear atributos que servirán para roteo ou nomes dinámicos.

### 3. Propiedades principais
| Propiedade      | Tipo   | Descrición                                       |
|-----------------|--------|--------------------------------------------------|
| Destination     | Enum   | `flowfile-attribute` ou `flowfile-content`.     |
| JSONPath        | Texto  | Ruta ex. `$.user.id`, `$.status`, `$.items[0]`. |
| Return Type     | Enum   | Tipo devolto (String, JSON…).                   |

### 4. Relacións
| Relationship | Significado                         |
|-------------|--------------------------------------|
| success     | JSON válido procesado               |
| failure     | Contido non é JSON válido          |

### 5. Exemplo
Extraer `$.status` para enrutar despois con `RouteOnAttribute`.

### 6. Situacións típicas
- Preprocesado de JSON.
- Extracción de claves para HDFS, Kafka ou MinIO.
- Validación de presenza de campos.

### 7. Erros comúns
| Erro               | Causa                      |
|--------------------|----------------------------|
| Valor null         | JSONPath incorrecto        |
| Vai a failure      | JSON mal formado           |

### 8. Boas prácticas
- Para JSON grande, mellor usar **ConvertRecord**.
- Manter JSONPath simple.
- Combinar sempre con LogAttribute ao principio.

---

## 1.7. RouteOnAttribute

### 1. Descrición
`RouteOnAttribute` enruta FlowFiles segundo condicións en atributos.

### 2. Función principal
- Crear ramas lóxicas do fluxo.
- Validación de datos.
- Dividir rexistros en rutas de éxito/erro.

### 3. Propiedades principais
Cada propiedade = unha relación nova:
| Nome da relación | Contido (EL)                    |
|------------------|----------------------------------|
| ok               | `${status:equals('OK')}`         |
| error            | `${status:equals('ERROR')}`      |

### 4. Relacións
| Relationship | Significado                                      |
|-------------|--------------------------------------------------|
| <nome>      | Condicións definidas polo usuario                |
| unmatched   | Ningunha condición cumprida                      |

### 5. Exemplo
Separar fluxo en `ok` e `error` segundo un atributo.

### 6. Situacións típicas
- Validación de rexistros.
- Roteo condicional por status, tamaño, tipo…
- Preparación de pipelines complexos.

### 7. Erros comúns
| Erro                  | Causa                       |
|-----------------------|-----------------------------|
| Todo vai a unmatched  | EL incorrecta               |
| Relacións non creadas | Propiedades mal definidas   |

### 8. Boas prácticas
- Engadir sempre unha ruta de fallback.
- Documentar condicións en labels.
- Combinar con EvaluateJsonPath.

---

## 1.8. RouteOnContent

### 1. Descrición
`RouteOnContent` enruta FlowFiles segundo contido (regex ou texto simple).

### 2. Función principal
- Clasificar FlowFiles polo seu contido.
- Validación básica de patróns.
- Útil para logs ou textos non estruturados.

### 3. Propiedades principais
| Propiedade   | Tipo  | Descrición                                    |
|--------------|-------|-----------------------------------------------|
| <nome ruta>  | Regex | Ex. patrón que indique OK/ERROR no contido.   |
| Match Strategy | Enum| `Contains`, `Regex`…                          |

### 4. Relacións
| Relationship | Significado                                      |
|-------------|---------------------------------------------------|
| <nome>      | Coincide co patrón definido                       |
| unmatched   | Non coincide con ningún patrón                    |

### 5. Exemplo
Detectar `"ERROR"` nun log.

### 6. Situacións típicas
- Logs sen estrutura clara.
- Detección de erros.
- Separación rápida de mensaxes.

### 7. Erros comúns
| Erro               | Causa                       |
|--------------------|-----------------------------|
| Sen matches        | Regex incorrecta            |
| Custos altos       | Regex pesada en ficheiros grandes |

### 8. Boas prácticas
- Preferir RouteOnAttribute cando xa hai atributos.
- Regex simples sempre que sexa posible.
- Probar no Process Group primeiro.

---

## 1.9. SplitContent

### 1. Descrición
`SplitContent` divide un FlowFile en múltiples partes segundo tamaño, número de liñas ou delimitadores.

### 2. Función principal
- Trocear ficheiros grandes.
- Separar logs liña a liña.
- Crear eventos pequenos a partir dun fluxo grande.

### 3. Propiedades principais
| Propiedade            | Tipo   | Descrición                          |
|-----------------------|--------|-------------------------------------|
| Split By              | Enum   | Tamaño, liñas, delimitador…         |
| Maximum Fragment Size | Tamaño | Tamaño máximo por fragmento         |
| Line Split Count      | Número | Número de liñas por fragmento       |

### 4. Relacións
| Relationship | Significado                             |
|-------------|------------------------------------------|
| splits      | Fragmentos xerados                       |
| original    | FlowFile orixinal                        |
| failure     | Erro no proceso de split                 |

### 5. Exemplo
Dividir un log de 200 MB en liñas individuais.

### 6. Situacións típicas
- Preparación de datos para Kafka.
- Mellorar paralelización.
- Evitar procesar un fichero monolítico.

### 7. Erros comúns
| Erro                   | Causa                            |
|------------------------|----------------------------------|
| Demasiados FlowFiles   | Split demasiado fino             |
| Non se reensambla      | Non usar MergeContent despois    |

### 8. Boas prácticas
- Limitar fragmentación.
- Usar atributos `fragment.*`.
- Conectar despois a `MergeContent` se se quere recompoñer.

---

## 1.10. MergeContent

### 1. Descrición
`MergeContent` combina varios FlowFiles nun só. É o complemento natural de `SplitContent`.

### 2. Función principal
- Reensamblar fragmentos.
- Xuntar rexistros pequenos nun lote maior.
- Construír ficheiros de saída.

### 3. Propiedades principais
| Propiedade                 | Tipo   | Descrición                           |
|----------------------------|--------|--------------------------------------|
| Merge Strategy             | Enum   | `Defragment`, `Bin-Packing`…        |
| Minimum Number of Entries  | Número | Mínimo de FlowFiles para facer merge |
| Maximum Number of Entries  | Número | Máximo por merge                     |
| Delimiter Strategy         | Enum   | Como separar contidos                |

### 4. Relacións
| Relationship | Significado                             |
|-------------|------------------------------------------|
| merged      | FlowFile unido                           |
| original    | FlowFiles orixinais                      |
| failure     | Fallo no merge                           |

### 5. Exemplo
Recombinar fragmentos xerados por `SplitContent` (modo `Defragment`).

### 6. Situacións típicas
- Preparar lotes para escritura en HDFS.
- Xuntar rexistros para optimizar uploads a S3/MinIO.
- Reverter splits.

### 7. Erros comúns
| Erro                  | Causa                              |
|-----------------------|------------------------------------|
| Merge non ocorre       | Non chegan suficientes FlowFiles   |
| Contido desordenado    | Estratexia incorrecta             |

### 8. Boas prácticas
- Revisar atributos `fragment.*`.
- Non crear FlowFiles de saída demasiado grandes.
- Usar Defragment cando vén de SplitContent.

---

